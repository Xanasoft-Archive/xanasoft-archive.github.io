{"id":830,"date":"2020-11-04T11:00:44","date_gmt":"2020-11-04T09:00:44","guid":{"rendered":"https:\/\/xanasoft.com\/?page_id=830"},"modified":"2023-08-15T09:12:35","modified_gmt":"2023-08-15T09:12:35","slug":"codeinjection","status":"publish","type":"page","link":"https:\/\/sandboxie-plus.com\/sandboxie\/codeinjection\/","title":{"rendered":"Code Injection"},"content":{"rendered":"<h1>Code Injection<\/h1>\n<p>Sandboxie employs a particularly low level approach of injecting its code into processes during creation.<\/p>\n<h5>Trigger<\/h5>\n<p>The driver registers a PsSetCreateProcessNotifyRoutine callback and when this is triggered inspects if the process should be sandboxed, when it decides so it blocks and requests the SbieSvc service to inject a loader into the process image. Alternatively a suspended process can be created and the driver triggered to put it into a sandbox by using API_START_PROCESS and resuming the process once the driver has finished. <\/p>\n<p>The injection mechanism itself can be adapted to be utilized without the driver. As of version 5.44 the loader code has been moved from the SbieSvc.exe to SbieDll.dll.<\/p>\n<h5>Overview<\/h5>\n<p>The Code Injection mechanism is made up of 3 components, the injector itself, a low-level shell code (LowLevel.dll), and the to be injected payload (SbieDll.dll). Note that the LowLevel.dll is embedded into the loader as a resource.<\/p>\n<h2>Remote Injection<\/h2>\n<p>The injection is done calling <code>_FX ULONG SbieDll_InjectLow(HANDLE hProcess, BOOLEAN is_wow64, BOOLEAN bHostInject, BOOLEAN dup_drv_handle)<\/code> and providing the required arguments, the function than:<\/p>\n<ul>\n<li>\n<p>Starts with preparing a data block <code>lowdata<\/code> of type <code>SBIELOW_DATA<\/code>, and filling in variouse values like is_wow64, bHostInject and others...<\/p>\n<\/li>\n<li>\n<p>Than it uses <code>SbieDll_InjectLow_CopyCode<\/code> to allocate <code>sizeof(shell_code) + sizeof(SBIELOW_J_TABLE) + 0x400<\/code> bytes of Memory in the target process and write the shell code to it.<br \/>\nThis function also, in an unrelated last step, copies 48 bytes from the begin of <code>ntdll!LdrInitializeThunk<\/code> into <code>lowdata.LdrInitializeThunk_tramp<\/code>.<\/p>\n<\/li>\n<li>\n<p>Than if <code>dup_drv_handle<\/code> was set <code>SbieDll_InjectLow_SendHandle<\/code> is used to open a handle to the driver and duplicate it into the process, saving its value to <code>lowdata.api_device_handle<\/code>.<\/p>\n<\/li>\n<li>\n<p>Than duplicates of a couple of required NTDLL functions are saved to the <code>lowdata<\/code> data block, and the address of the <code>SBIELOW_J_TABLE<\/code> section is stored to <code>lowdata.Sbie64bitJumpTable<\/code>.<\/p>\n<\/li>\n<li>\n<p>Than the actual trampoline is build by <code>SbieDll_InjectLow_BuildTramp<\/code> in <code>lowdata.LdrInitializeThunk_tramp<\/code>.<\/p>\n<\/li>\n<li>\n<p>Now the function uses <code>SbieDll_InjectLow_CopySyscalls<\/code> to allocate and fill in another memory segment <code>syscall_data<\/code>.<br \/>\nThis block is made up of 2 sections one containing information from the driver that are used to hook all system calls,<br \/>\nthis is optionally done by the shell code when <code>bHostInject == 0<\/code>, that is followed by the <code>SBIELOW_EXTRA_DATA<\/code> that points to values stored behind it in the memory block.<br \/>\nThe data stored there a couple of offsets, as well as the full paths to the SbieDll.dll that is to be injected later on.<\/p>\n<\/li>\n<li>\n<p>The address of that auxiliary memory is saved to <code>lowdata.syscall_data<\/code> and the <code>lowdata<\/code> block is written with <code>SbieDll_InjectLow_CopyData<\/code> directly into the shell code memory.<\/p>\n<\/li>\n<li>\n<p>Finally the <code>ntdll!LdrInitializeThunk<\/code> in the target process gets overwritten using <code>SbieDll_InjectLow_WriteJump<\/code> with a jump instruction into the shell code's entry point.<\/p>\n<\/li>\n<\/ul>\n<p>Now the process can be resumeed and the injected code will do its thing.<\/p>\n<p>An important note to make here is that this function does the same for native 64 bit and wow64 emulated 32 bit processes,<br \/>\nin fact, on a 64-bit system the injected shell code is always 64 bit. Only much later in the initialization of the process running under wow64 it switches to 32-bit.<\/p>\n<h2>Shell Code (LowLevel.dll) operation<\/h2>\n<p>The LowLevel.dll is written partially in assembler and partially in C, its base address is set to 0 to gain position independence.<br \/>\nThe initial entry point <code>_Start<\/code> retrieves the current address and calculates the addresses of the data block <code>data<\/code> of type <code>SBIELOW_DATA<\/code> and those of a couple of helper functions written in assembler, with those values as parameter it calls the <code>EntrypointC<\/code> function handing off the operation to the C portion.<\/p>\n<p>The <code>EntrypointC<\/code> function ensures that it will be executed only once, using a spinlock, and then checks if the <code>data-&gt;bHostInject<\/code> field is set to <code>0<\/code> it first hooks all the ntdll sys call functions using <code>InitSyscalls<\/code> than it prepares the later loading of the SbieDll.dll using <code>InitInject<\/code> and , on 64 bit systems only, it calls <code>InitConsole<\/code> to modify the ConsoleHandle. If <code> bHostInject != 0<\/code> the function only calls <code>InitInject<\/code>. Last the trampoline to the original function<code> data-&gt;LdrInitializeThunk_tramp<\/code> is called.<\/p>\n<h5>InitInject<\/h5>\n<p>The <code>InitInject<\/code> function checks if the process is running natively (i.e. 32-bit on a x86 system or 64-bit in a x64 system), or if it's running under wow64 (that is a 32-bit process on a 64-bit system) and selects either the native ntdll base address or the one of the wow64 ntdll. On Windows versions prior to 8, that address was located in <code>KUSER_SHARED_DATA::Wow64SharedInformation<\/code> structure, but not on later versions. Sandboxie used the driver to record the address of the wow64 ntdll during image loading and <code>InitInject<\/code> queried the driver for it. Since version 5.44, however, it's driver independent, the loader code uses <code>NtQueryVirtualMemory<\/code> to find the image base address and saves it into the <code>ntdll_wow64_base<\/code> field of the data block.<\/p>\n<p>At this point the top portion of the <code>data-&gt;syscall_data<\/code> before the <code>SBIELOW_EXTRA_DATA<\/code> region is no longer required and is repurposed to store temporary data of the type <code>INJECT_DATA<\/code>.<\/p>\n<p>The function than finds the addresses of <code>LdrLoadDll<\/code>, <code>LdrGetProcedureAddress<\/code>, <code>NtRaiseHardError<\/code> and <code>RtlFindActivationContextSectionString<\/code> using a custom <code>FindDllExport<\/code> lookup function by parsing through the previously selected ntdll image, these addresses are stored into the <code>INJECT_DATA<\/code> region, then a couple values from the <code>SBIELOW_EXTRA_DATA<\/code> are also copied into that region, containing paths to the SbieDll.dll (booth 32 and 64 bit paths), as well as the name of kernel32.dll.<\/p>\n<p>On 64-bit systems the function distinguishes between the native and the wow64 execution, in the latter case branching of to <code>InitInjectWow64<\/code>.<br \/>\nIn the native case it continues with hooking the <code>RtlFindActivationContextSectionString<\/code> function in the ntdll.dll. <\/p>\n<ul>\n<li>An original copy of the functions begin is first saved to the <code>INJECT_DATA<\/code> structure <\/li>\n<li>The address of the structure is written into the detour function which is implemented in assembler. <\/li>\n<li>Than the <code>RtlFindActivationContextSectionString<\/code> begin is overwritten with a jump instruction to the detour function.<\/li>\n<li>Last a pointer to the <code>SBIELOW_DATA<\/code> region is saved into the very top of the <code>INJECT_DATA<\/code> region, and the function exits.<\/li>\n<\/ul>\n<p>In the wow64 case <code>InitInjectWow64<\/code> sets up the <code>RtlFindActivationContextSectionString<\/code> hook on the 32-bit version of the function in the wow64 ntdll.dll in a similar way.<\/p>\n<h5>RtlFindActivationContextSectionString Detour<\/h5>\n<p>In contrary to the above operations which are always executed natively, the <code>RtlFindActivationContextSectionString<\/code> Detour function is executed in the mode matching the bit-ness of the started process. <\/p>\n<ul>\n<li>The function first restores the original <code>RtlFindActivationContextSectionString<\/code> begin.<\/li>\n<li>Than it loads the kernel32.dll followed by loading the SbieDll.dll and retrieving the address of Ordinal 1.<\/li>\n<li>Than it saves value of the first argument to the <code>INJECT_DATA<\/code> structure and replaces it with a pointer to said structure<\/li>\n<li>Finally, it jumps to address of Ordinal 1, it uses a jump rather than call to invoke it so that when it returns it will return directly to the current caller.<\/li>\n<\/ul>\n<h2>Payload (SbieDll.dll) operation<\/h2>\n<p>The SbieDll.dll hook entry point <code>Dll_Ordinal1<\/code> function starts of by obtaining a few required values from the <code>INJECT_DATA<\/code> structure that was passed as first argument, like the address of <code>SBIELOW_DATA<\/code> data block, and the original value of the first argument. Having copied the required values, it can free the no longer needed <code>INJECT_DATA<\/code>, formally <code>syscall_data<\/code> region.<br \/>\nThe function now checks if <code>bHostInject<\/code> is set to <code>0<\/code> in which case it Calls <code>SbieDll!Dll_InitInjected<\/code> this function hooks pretty much everything, ?, last but not least it calls <code>SbieDll!Ldr_Init<\/code> which sets up callbacks for dll loading and calls <code>SbieDll!Ldr_Inject_Init<\/code>. If <code>bHostInject != 0<\/code> however <code>SbieDll!Ldr_Inject_Init<\/code> is called directly from <code>Dll_Ordinal1<\/code>. Once the initialization is completed <code>Dll_Ordinal1<\/code> runs the real <code>RtlFindActivationContextSectionString<\/code> with its original arguments and returns.<\/p>\n<p>As if all this hooking wouldn?t be enough <code>SbieDll!Ldr_Inject_Init<\/code> sets up yet an other hook, this time targeting the actual entry point of the starting process. The function saves the initial bytes of the entry point, and overwrites it with a jump to <code>SbieDll!Ldr_Inject_Entry64<\/code> or to <code>SbieDll!Ldr_Inject_Entry32<\/code> respectively.<br \/>\nThose are implemented in assembler, they pass a pointer to the return address location as argument to <code>SbieDll!Ldr_Inject_Entry<\/code> and clean up the stack, then they return to the begin of the entry point.<\/p>\n<h5>Ldr_Inject_Entry<\/h5>\n<p>This function first restores the original entry point function from <code>SbieDll!Ldr_Inject_SaveBytes<\/code>  and changes its caller?s return address to point to the begin of the entry point. This way once the caller returns the real entry point will be invoked. Then the function checks if <code>bHostInject<\/code> is set to <code>0<\/code> in which case it first calls <code>SbieDll!Ldr_LoadInjectDlls<\/code> and then <code>SbieDll!Dll_InitExeEntry<\/code> which performs the last initialization steps. If <code>bHostInject != 0<\/code> it calls only <code>SbieDll!Ldr_LoadInjectDlls<\/code> this function checks the <a href=\"SandboxieIni\">Sandboxie.ini<\/a> for the <a href=\"InjectDll\">InjectDll<\/a> or the <a href=\"InjectDll64\">InjectDll64<\/a> respectively, and loads the additional dll?s if any are configured.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Code Injection Sandboxie employs a particularly low level approach of injecting its code into processes during creation. Trigger The driver registers a PsSetCreateProcessNotifyRoutine callback and when this is triggered inspects if the process should be sandboxed, when it decides so it blocks and requests the SbieSvc service to inject a loader into the process image. &hellip; <a href=\"https:\/\/sandboxie-plus.com\/sandboxie\/codeinjection\/\" class=\"more-link\">Continue reading <span class=\"screen-reader-text\">Code Injection<\/span> <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"parent":108,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"footnotes":""},"_links":{"self":[{"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/pages\/830"}],"collection":[{"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/comments?post=830"}],"version-history":[{"count":3,"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/pages\/830\/revisions"}],"predecessor-version":[{"id":2619,"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/pages\/830\/revisions\/2619"}],"up":[{"embeddable":true,"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/pages\/108"}],"wp:attachment":[{"href":"https:\/\/sandboxie-plus.com\/wp-json\/wp\/v2\/media?parent=830"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}